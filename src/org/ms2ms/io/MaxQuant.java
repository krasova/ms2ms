package org.ms2ms.io;

import org.ms2ms.data.ms.LcMsMsDataset;
import org.ms2ms.r.Dataframe;
import org.ms2ms.r.Var;
import org.ms2ms.utils.IOs;
import org.ms2ms.utils.Stats;

import java.util.Arrays;
import java.util.Map;

/** Information and algorithms regarding Maxquant output
 *
 * ** Copyright 2014-2015 ms2ms.org
 * Author: wyu
 * Date:   11/6/14
 */
public class MaxQuant
{
  public static final String V_RT     = "RT";
  public static final String V_MZ     = "m/z";
  public static final String V_TIC    = "TIC";
  public static final String V_FOFFSET = "Pointer";

  public static String[] sRmdEvidence = {"Sequence","Length","Modifications","Oxidation (M) Probabilities","Oxidation (M) Score Diffs","Acetyl (Protein N-term)","Oxidation (M)","Missed cleavages","Proteins","Leading Proteins","Leading Razor Protein","TypeMatch time difference","Match m/z difference","Match q-value","Match score","PIF","Fraction of total spectrum","Base peak fraction","Reverse","Contaminant","Combinatorics","AIF MS/MS IDs","Oxidation (M) site IDs","Type","Protein group IDs"};
  public static String[] sRmdMsms     = {"Precursor","Sequence","Length","Missed cleavages","Modifications","Oxidation (M) Probabilities","Oxidation (M) Score Diffs","Acetyl (Protein N-term)","Oxidation (M)","Proteins","Fragmentation","Mass analyzer","Type","Score diff","Localization prob","Combinatorics","PIF","Fraction of total spectrum","Base peak fraction","Precursor Full ScanNumber","Precursor Intensity","Precursor Apex Fraction","Precursor Apex Offset","Precursor Apex Offset Time","Matches","Intensities","Mass Deviations [Da]","Mass Deviations [ppm]","Masses","Neutral loss level","ETD identification type","Reverse","All scores","All sequences","All modified sequences","Oxidation (M) site IDs","Scan type","Modified sequence","PEP","Score","Delta score","Protein group IDs"};
  public static String[] sRmdScan     = {"Collision energy","Summations","Identified","MS/MS IDs","Sequence","Length","Mass analyzer","Parent intensity fraction","Fraction of total spectrum","Base peak fraction","Precursor full scan number","Precursor intensity","Precursor apex fraction","Precursor apex offset","Precursor apex offset time","Proteins","Score","Intens Comp Factor","CTCD Comp","RawOvFtT","AGC Fill","Modified sequence","PEP","Score","Delta score","Protein group IDs"};

  private String    mResultDir, mRawDir;
  private Dataframe mSummary, mMsMs;

  public MaxQuant() { super(); }
  public MaxQuant(Dataframe msms) { super(); mMsMs=msms; }
  public MaxQuant(String result, String raw) { mResultDir=result; mRawDir=raw; }

  public void init()
  {
    // grab the summary first
    mSummary = Dataframe.readtable(mResultDir+"summary.txt",'\t').setTitle("summary");
    mSummary = mSummary.subset("Raw file!='Total'");

    Dataframe survey = MsReaders.surveyMzXML(mSummary.getStrCol("Raw file"), mRawDir, mRawDir+"cache.ms2", null, 2);

    IOs.write(mResultDir+"scan_survey.txt", survey.display("\t").toString());

    // read the tables of MS/MS scans
    mMsMs = readMsMsWithAnnotations();
    Dataframe offsets = Dataframe.merge(mMsMs, survey, true, "Raw file", "Scan number").setTitle("offsets");

    IOs.write(mResultDir+"/composite_scans.txt", offsets.display("\t").toString());
  }
  public Dataframe readMsMsWithAnnotations() { return readMsMsWithAnnotations(mResultDir); }
  public Dataframe readMsMsWithAnnotations(String root)
  {
    mResultDir = root;

    Dataframe evidences = Dataframe.readtable(root+"evidence.txt",  '\t').removeCols(MaxQuant.sRmdEvidence).setTitle("evidence");
    Dataframe msms      = Dataframe.readtable(root+"msms.txt",      '\t').removeCols(MaxQuant.sRmdMsms).setTitle("msms");
    Dataframe scans     = Dataframe.readtable(root+"msmsScans.txt", '\t').removeCols(MaxQuant.sRmdScan).setTitle("scan");

    // replace the "id" variable with "Evidence ID" so they can be joint
    evidences.renameCol("id", "Evidence ID");
    evidences.renameCol("m/z", "m/z-calibrated");
    evidences.renameCol("Mass", "Mass-predicted");
    evidences.renameCol("Retention time", "RT-feature-calibrated");

     msms.renameCol("Retention time", "RT-MS2");
    scans.renameCol("Retention time", "RT-MS2");

    // force the ID columns to be categorical
    msms.init(     Var.VarType.CATEGORICAL, "Evidence ID");
    evidences.init(Var.VarType.CATEGORICAL, "Evidence ID");
    // join the msms table with the evidence table, which contains the annotated LCMS features by the Evidence ID
    Dataframe annotations = Dataframe.merge(msms, evidences, true, "Evidence ID").setTitle("annot");
    // msms.txt contains only the annotated scans, msmsScans.txt has all the scans
    mMsMs = Dataframe.merge(annotations, scans, true, "Raw file","Scan number");

    IOs.write(root + "mergedAnnotAll.txt", annotations.display("\t").toString());
    IOs.write(root + "mergedScansAll.txt", mMsMs.display("\t").toString());
    return mMsMs;
  }
  public void imputeRT(Dataframe data, float rttol) throws Exception
  {
    if (data==null || !data.hasVars("Raw file","Retention time","Retention time calibration","Calibrated retention time start")) return;

    Map<Object, Dataframe> raw_data = data.split("Raw file");
    // go thro the run separately
    for (Dataframe d : raw_data.values())
    {
      double xs[] = d.getDoubleCol("Retention time");
      double ys[] = d.getDoubleCol("Retention time calibration");
      double Xs[] = d.getDoubleCol("Calibrated retention time start");

      double[] Ys = Stats.interpolate(xs, ys, rttol, Xs);
      d.addVar("interpolated", Ys);
      d.addVar("Calibrated RT", Stats.sum(d.getDoubleCol("Retention time"), d.getDoubleCol("Retention time calibration")));
    }
  }
}
